# Pokemon
Pokemon is a minimal css framework for web
## Overview

# 定义力

## 定义方法
- 内核定义法-本质定义
- 外框定义法-外貌特征（本体）背景环境（界面，平台）定义
- 比喻定义法-形象类比定义
- 科学定义法-内核定义+外延定义
## 定义原则

# 划分法

## 划分方法
- 分层法-层级划分
- 分类法-类别划分
- 分元法-组成元素划分

## 划分原则
- 整体性原则-穷尽所有，无所遗漏
- 不相容原则-子项独立
- 一维性原则-每次划分，标准唯一
- 效率性原则-抓大放小，近似等值。

# 概括力（重点）

## 概括方法
- 抓大放小法-重点概括
- 无形求同法-共性概括
- 以小见大法-宏观概括-现象道理概括
- 由表及里法-表面本质概括

## 概括重点
- 抓大放小法抓核心
- 无形求同提炼概括-追求本质
- 以小见大由现现象联想的大道理
- 由表及里层层递进，对信息更深层次挖掘

# 判断力

## 判断方法
- 一维判断法-从事物自身角度-就事论事
- 二维判断法-从事物和环境角度-具体问题具体分析
- 立体判断法-事物和宏观（社会）角度-放在大环境中

# 推理力
## 思维工具
- 分解推理法-大问题分解多个小问题
  ```
  为什么许多人没有理想 什么是理想，...
  ```
- 类比推理法-类比其他事物，发现新思路
- 因果推理法-事物因果关系链
- 假设推理法-打单假设
- 排除推理法

## 操作要点

# 假说力
## 思维工具
- 假设分析法


## 特征及原则
- 事物特征
- 创建事物原则

# 前端Leader如何制定前端协作规范

```
无规矩不成方圆，规矩只是为了更好的管理。规矩也必须要遵守，落实才能达到更好的效果，不然一切都是空谈。
```

## 什么是规范
规范，顾名思义就是明文规定或约定成俗的标准，如：道德规范，技术规范等。动词的意思是：按照既定的标准，规范要求进行操作，使某一行为或活动达到或超越规范的标准，如规范管理，规范操作，规范流程。前端规范就是在前端领域中的标准。

## 为什么需要规范
- 团队实现高度统一，提高开发效率，协作效率，降低沟通成本。
- 降低新成员融入团队的成本，同时也一定程度避免挖坑。
- 规范是一个团队知识沉淀的直接输出
- 规范是实现自动化的基础

## 前端规范包含哪些内容
前端规范不单单只是指编码规范，它包括前端开发中的方方面面，如工作流规范，代码库管理规范，代码规范，项目组织规范，测试规范等等，下面详细一些前端规范。


## 1 工作流规范
- 开发
  - 版本规范
  - 版本控制系统规范
  - commit提交信息规范
- 构建
  统一构建脚手架工具链，这套工具应该遵循“约定大于配置”，让开发者更专注于业务开发
- 发布工作流规范
  发布工作流指的是将“软件成品”对外发布的一套流程，将这一套流程规范化后，可以使用工具实现自动化
- 持续集成
- 任务管理

## 技术栈规范
目前前端技术栈有Vue,React和AngularJs三大框架，这三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样的，一个库的替换成本很低；而框架的背后是一个架构，一个生态。每个框架背后牵涉着开发思维，生态系统，配套工具，最佳实践，性能调优。要精通和熟练一个框架需要付出的成本很高。所有一个团队的开发效率是基于稳定且熟练的技术栈的。稳定的技术栈规范有利于团队协作和沟通。前端技术栈规范主要有如下
- 编程语言-Typescript或JavaScript
- UI框架及其配套生态
  - UI框架
  - 路由
  - 状态管理
  - 组件库
  - 国际化
  - 动画
  - 服务端渲染
  - 脚手架，Cli工具
  - 组件测试
- 样式，包含命名规范，预处理器，方法论等
- 动画引擎
- QA,包括测试，Lint,格式化工具，监控
- 项目构建工具流，例如webpack,vue-cli
- 包管理器。npm,yarn
- 项目管理工具
- 时间处理
- 模板引擎
- 开发工具
- 后端开发框架
- 工具库
- 开发/调试工具
- 等
### 技术选型
### 学习新技术

## 项目组织规范
- 通用的项目组织规范
- 目录结构的风格
- 脚手架和模板项目
  

## 编码规范
- JavaScript
- Html
- Css
- 代码格式化
- 集大成的
- 特定框架风格指南
  
## UI设计规范

## 测试规范

## 文档规范

## 前后端协作规范

## 异常处理，监控和调试规范

## 浏览器兼容规范

## 培训/招聘/知识管理/技术沉淀规范





# 使用ESLint + prettier统一前端代码规范和风格


## 表单校验最佳实践
## 配置型表单最佳实践
## 吸顶锚点组件实践
## vue中后台权限实践
## js工具库最佳实践

## vue-component
- 如何开发一个vue组件
  - 建立组件git库
  - 搭建脚手架如（ https://github.com/react-component/generator-rc）
  - 约定目录结构
  - 源码开发
- vue组件代码规范
  - js源码规范
  - js注释规范
  - css源码规范
- vue组件设计原则
  - 职责清晰
  ```
  多个组件协同完成一件事情，而不是一个组件代替其他组件完成完成事情，如
    <Menu> // menu1
    <MenuItem></MenuItem>
    <SubMenu>
      <Menu> // menu2
      </Menu>
    </SubMenu>
    </Menu>
  ```
  - 扁平访问
  ```
  组件推荐使用状态来控制交互和显示，如果需要显示访问，也尽量实行扁平访问，即只可以调用其 children 的方法
  ```
  - 信息冗余
  ```
  尽量避免信息冗余，如果某个 state 可以由其他 state 计算得到，那么就删除这个 state,
  ```
  - api尽量和已知概念保持一致
  ```
  如果 api 可以和已知概念保持一致，那么就用已知的 api, 如key代表子组件，父组件使用activeKey
  ```
  - 使用标签嵌套
  ```
  尽量使用标签嵌套而不是使用属性配置；如：
  <Tabs>
  <TabPane tab="title1" key="2"><a>1</a></TabPane>
  <TabPane tab="title2" key="1"><a>2</a></TabPane>
  </Tabs>
  代替
  <tabs panels={[{tab:'t1',pane:<a>1</a>}, {tab:'t2',pane:<a>2</a>}]}/>
  ```
  - 避免使用ref
  ```
  使用父组件的state控制子组件的状态而不是直接通过ref操作子组件
  ```

基础组件库的需求
- 丰富的feature
- 文档 & demo
- 组件库的安装 & 引入
- 工程化： 开发， 测试， 构建，部署， 持续集成


  # 现代前端开发
   现代前端开发使用的框架或者库是react,vue,angluar。出现的根本原因是UI与状态同步，其他的原因是它们支持组件化，适合做单页应用
   特点：
   - 数据驱动
   - 虚拟DOM



  # 前端工程化
  前端工程化经历三个阶段，库/框架选型（解决开发效率）-构建优化（提高运行性能）-js/css模块化（提交维护效率）
  - 模块化
  模块化是对文件，对代码和资源的拆分
  - 组件化
  组件化是对UI层面的拆分
  - 规范化
    在开发初期以及开发期间制定的系列规范
  - 自动化
    自动化合并，构建，打包。。。持续集成，自动化测试


  # js标准库   ecmascript标准内置对象（global）及及浏览器层面的webApi


  # 早期的JavaScript诞生设计思路
  - 借鉴C语言的基本语法；
  - 借鉴Java语言的数据类型和内存管理；
  - 借鉴Scheme语言，将函数提升到"第一等公民"（first class）的地位；
  - 借鉴Self语言，使用基于原型（prototype）的继承机制。


  # Dom编程
  HTML是描述网页的一个语言，html不是编程语言，是一个标记语言-超文本标记语言；标记语言是一套标记标签，HTML使用标记标签（html标签）描述网页；HTML标签定义HTML文档内容；Html文档描述网页，Html文档包含HTML标签和纯文本，HTML文档也被称为网页。
  Css层叠样式表（样式语言）定义如何显示HTML元素，为了解决 内容与表现分离的问题（为图文信息展示服务的），多个样式可以层叠为一个。特点，层叠策略灵活
  DOM是Html与xml文档的编程接口；html Dom定义了访问和操作html文档的标准方法；DOM以树结构表达HTML文档（HTML文档在浏览器中以DOM树结构呈现）。HTML文档如何通过浏览器渲染成DOM树。DOM(html文档的编程接口)一直在升级变化。
  DOM 0级
  规定了一套文档对象，集合，方法和属性
  DOM 1级规范
  有两个子规范组成
  DOM Core
  DOM HTML

  DOM 2级规范
  由6个子规范组成
  DOM2 Core
  DOM2 HTML
  DOM2 EVent
  DOM2 Style
  DOM2 Traversal和DOM2 Range

  DOM 3级规范
  由3个子规范组成
  DOM3 Core
  DOM3 Load and Save
  DOM validation
  DOM 4级规范



  作用域及闭包
  this和原型
  类型和语法
  异步编程
  模块化
  富文本

框架设计思维
容器思维
发布订阅思维


学习
专业书学习
源码学习


js模块化及Css模块化
无模块化-函数写法-对象写法-自执行函数-CommonJS-AMD-CMD-ES6 Module
使用less,sass使Css模块化

JS 的运作机制可以分为 AST 分析、引擎执行两个步骤

JavaScript单线程运行机制

网页渲染流程

web发展及前端发展
web1.0 主要为图文信息服务
web2.0 Ajax应用,网页交互服务
web3.0主要为富图形和富媒体服务

web应用
web开发语言
前后端分离
web安全
web状态
web缓存
web服务端与客户端渲染

Vue项目性能优化
  - Vue代码层面优化
  - webpack配置层面优化
  - web技术层面的优化
JavaScript语言特性
- 解释型脚本语言-不用预编译，直接解析执行
- 基于原型- 一切皆对象
- 动态弱类型 - 简单，灵活
- 单线程-事件驱动
- 跨平台-与操作系统无关
前端模块化技术
前端异步方案技术

webpack前端工程化的js模块化打包工具
babel js语法编译器
eslint 前端工程化编程规范统一的工具
cli脚手架 前端最佳实践工具
sass css预编译处理工具-css模块化工具
postcss css后置处理工具-css语法编译替换
gulp js任务流工具

每一个设计都有设计理念或设计准则支撑
前端的本质是用户与产品之间的接口

# 框架（提供更好的可维护性）
 现在前端框架的意义在于为你掩盖底层的DOM操作，让您用声明式的方式来描述你的目的，从而让你的代码更容易维护。。没有任何框架可以比纯手动的优化DOM操作更快，因为框架的DOM操作层需要应对任何上层API可以产生的操作，它的实现必须时普适的。针对任何一个benchmark,我都可以写出任何框架更快的手动优化，但是哪有什么意义，构建一个实际应用的时候，不可能未每一个地方都去手动优化，因为这样构建的应用可维护太差了，框架给你的时，您不需要手动优化的情况下，我依然可以给你提供过的去的性能。。

架构设计
# 领域驱动设计在前端中应用

## 业务领域

## 前端领域设计与结构分层
![image](http://static4.vince.xin/E3D6DA30-6C81-44F0-8D01-FE8BA8E0AA5E.png)


# 微服务架构及微前端
微
功能业务分层 功能为一级，业务为二级
业务功能分层 业务为一级， 功能为二级


# 编程本质
数据类型就好像螺帽一样，有多种接口方式，而螺丝刀就像函数，用来操作这些螺丝的算法或代码，不同类型的螺帽（数据类型），需要适配不同的螺丝刀。。电工就好比程序员。。。
编程范式 或者说程序设计的方法
programs = Algorithms + Data Structures 编程 = 算法 + 数据结构
Algorithm = Logic + Control 算法 = 逻辑 + 控制
程序的本质是 Logic + Control + Data,
Logic部分才是真正有意义的（what）,Control部分只是营销Logic部分的效率（How）
## Control如何与Logic分离
  - State Machine
  - DSL
  - 编程范式
    - 面向对象： 委托，策略，桥接，修饰， Ioc/Dip， MVC...
    - 函数式编程
      - 修饰
      - 管道
      - 拼装
    - 逻辑推导示编程
      - Prolog
## 编程范式
目前世界上主要有四大编程范式，分别为命名式，函数式，面向对象，声明式。每一门编程语言都有其对应的编程范式。
声明式编程范式（函数式和逻辑式）偏向于你定义要什么，而不是怎么做(描述你要干什么，而不是怎么干)，命令式编程范式和面向对象编程范式偏向于怎么做，而不是要做什么。一边是在解决数据和算法，一边是在解决逻辑和控制。
  - 声明式编程范式
  - 命名式编程范式
  - 逻辑式-声明式编程范式
  - 函数式-声明式编程，抽象更大，实现方式上，有函数套函数，函数返回函数，函数里定义函数。
  - 面向对象- 有状态的，有类型的
  - 面向过程- 指令式编程。 把具体的流程描述出来。
## 泛型编程
一个好的泛型编程需要解决如下几个泛型编程的问题：
- 算法的泛型
- 类型的泛型
- 数据结构（数据容器）的泛型

## 类型系统和泛型的本质
在编程世界中，需要处理两件事。第一件事是编程语言中的类型问题（类型系统）。第二件事是对真实世界中业务代码的抽象，重用和拼装（泛型编程）
程序语言的类型系统提供如下功能。
类型是对底层内存布局的一个抽象，不同类型有不同的算法
任何语言都有类型系统。
类型的本质： 类型是对内存的一种抽象。不同的类型会有不同的内存布局和内存分配的策略。不同的类型，有不同的操作。所有对于特定的类型，也有特定的一组操作。
泛型编程的本质： 屏蔽掉数据和操作数据的细节让算法更为通用（标准化），让编程者更多地关注算法和结构，而不是在算法中处理不同的数据类型。
## 函数式编程
把一个功能或逻辑代码通过函数瓶装的方法来组织的玩法。
用函数定义输入数据和输出数据相应的关系。输入数据和输出数据关系是什么样的，是用函数来定义的。
关注的是做什么而不是怎么做，因为被成为声明式编程。
### 特征
- stateless : 函数不维护任何状态。
- immutable : 输入数据是不能动的。

### 函数式编程用到的技术
- first class function(头等函数)
- tail recursion optimizaation (尾递归优化)
- map & reduce
- pipeline(管道)，将函数实例化成一个一个action,然后将一组action放到数组或列表中，再把数据传递给这个action list
- recursing(递归)，简化代码
- currying(柯里化)
- 高阶函数-把函数当参数，把传递的函数做一个封装，返回封装函数。

### 函数式语言的三套件
描述你要干什么，而不是怎么干，业务是描述要搞什么，控制是描述怎么干。。。
- Map
- Reduce
- Filter

### 函数式的PipeLine模式
把若干个命令串起来，前面的命名的输出成为后面命名的输入。。

## 修饰器模式
模式动用了函数式编程的一个高阶函数技术，用一个函数构造另一个函数。
- 修饰器模式就是扩展现有的一个函数的功能，让他可以干一些其他的事。
- Decorator这个函数可以修饰机会所有的函数。。可以将一些非业务功能的，属于控制类型的代码给抽象出来（控制类型的代码 for-loop，打日志，函数路由，求函数运行时间之类的非业务功能代码）


## 委托模式
具有泛型编程也有map,reduce,filter只关心控制流程（做什么），Ioc控制反转


## 招式与内功
Java等编程语言，VSCode等开发工具，JSP等开发技术，Struts,Koa等框架技术都是招式，数据结构，算法，设计模式，重构，软件工程等未内功。

## 设计模式
设计模式起源于建筑领域，每一个模式都从Context(前提条件)，Theme或Problem(目标问题)，Solution(解决方案)三个方面进行了描述。
模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。
软件模式是在软件开发中某些可重现问题的一些有效解决方法，软件模式的基础结构主要有四部分构成，包括问题描述（待解决的问题是什么），前提条件（在何种环境或约束条件下使用），解法（如何解决）和效果（有哪些优缺点）。。软件模式不仅仅是设计模式，还包括架构模式，分析模式和过程模式等。

设计模式是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结，是哦那个设计模式是未了可重用代码，让他代码更容易被他人理解并且保证代码可靠性。

设计模式一般包括模式名称，问题，解决方案，效果等组成要素。绝大多数的模式都市根据功能或模式结构来命名的，问题描述了应该何使使用模式，它包含了设计中存在的问题以及问题存在的原因；解决方案描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的之责和协作方法，通常解决方案通过UML类图和核心代码来进行描述；效果描述了模式的优缺点以及在使用模式时应权衡的问题。

GoF设计模式分为23个，每个模式都为某一个可重复的设计问题提供了一套解决方案。。根据用途，设计模式分为创建型，结构型和行为型三种，其中创建型5种，结构型7种和行为型有11种。常见行模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，型卫星模式主要描述类或对象怎么交互以及怎么分配职责。根基模式主要用于处理类之间的关系还是对象之间的关系，设计模式分为类模式和对象模式，一般将两种分类方式结合使用，如单例模式是对象创建型模式，模板方法模式是类行为型模式。

设计模式特征
- 反复使用的
- 软件开发通用的
- 可重用和可拓展的

设计原则
对于面向对象软件系统的设计而言，除了支持可维护性的同时，提高系统的可复用性也是一个至关重要的问题。。提高软件系统的可维护性和可复用性时面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护型的复用时以设计原则为基础的。。。每一个原则都蕴含一些面向对象设计的思想，可以从不同角度替身一个软件结构的设计水平。
面向对象设计原则为支持可维护性复用性而诞生，这些原则蕴含在很多设计模式中。他们时从许多设计方案中总结出的指导性原则。
单一职责原则（SRP） 一个类只负责一个功能领域中的相应职责
开闭原则（OCP）软件实体应对扩展开放，而对修改关闭
里氏替换原则（LSP） 所有引用基类对象的地方能够透明地使用其字类的对象
依赖倒转原则（DIP） 抽象不应该依赖于细节，细节应该依赖于抽象
接口隔离原则(ISP) 使用多个专门的接口，而不使用单一的总接口
合成复用原则（CRP）  尽量使用对象组合，而不是继承来达到复用的目的
迪米特法则（LoD） 一个软件实体应当尽可能少地与其他实体发生相互作用

## 单一职责原则

单一职责原则时最简单的面向对象设计原则，用于控制类的粒度大小。。单一职责原则定义如下： 一个类只负责一个功能领域中的相应职责。
单一职责原则是实现高内聚，低耦合的指导方针；
单一职责原则告诉我们一个类不能太“累”，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小

## 开闭原则
如何一个系统在扩展时时涉及到修改配置文件，而原有的Java代码没有做任何修改，改系统即可认为时一个符合开闭原则的系统

## 里氏替换原则
里氏替换原则告诉我们，在软件中将一个迹类对象替换成它的字类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的时一个子类对象的话，那么它不一定额能够使用基类对象。
里氏替换原则时实现开闭原则的重要方式之一。 针对基类编程，在程序运行时再确定具体子类。